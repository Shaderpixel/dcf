{"version":3,"sources":["common/dcf-lazyLoad.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","root","factory","define","amd","exports","module","dcfLazyLoad","undefined","images","document","querySelectorAll","imageCount","length","observer","window","IntersectionObserver","entries","disconnect","_i2","entry","intersectionRatio","unobserve","target","preloadImage","rootMargin","threshold","i","image","classList","contains","observe","_i","_image","loadImagesImmediately","url","src","dataset","Promise","resolve","reject","Image","onload","onerror","then","img","add","applyImage","lazyLoad"],"mappings":";;;;;;;AAAA,aAEA,IAAIA,QAA4B,mBAAXC,QAAoD,iBAApBA,OAAOC,SAAwB,SAAUC,GAAO,cAAcA,GAAS,SAAUA,GAAO,OAAOA,GAAyB,mBAAXF,QAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOI,UAAY,gBAAkBF,IAErQ,SAAWG,EAAMC,GACM,mBAAXC,QAAyBA,OAAOC,IACzCD,UAAWD,GACoE,YAAlD,oBAAZG,QAA0B,YAAcV,QAAQU,UACjEC,OAAOD,QAAUH,IAEjBD,EAAKM,YAAcL,IANtB,MAQEM,EAAW,WAIZ,IAAIC,EAASC,SAASC,iBAAiB,iBASnCC,EAAaH,EAAOI,OACpBC,OAAW,EAGf,GAAM,yBAA0BC,OAEzB,CAELD,EAAW,IAAIE,qBAoEjB,SAAwBC,GAEH,IAAfL,GACFE,EAASI,aAIX,IAAK,IAAIC,EAAM,EAAGA,EAAMF,EAAQJ,OAAQM,IAAO,CAC7C,IAAIC,EAAQH,EAAQE,GAEhBC,EAAMC,kBAAoB,IAC5BT,IAGAE,EAASQ,UAAUF,EAAMG,QACzBC,EAAaJ,EAAMG,YAhGvBE,WAAY,MAEZC,UAAW,KAcX,IAAK,IAAIC,EAAI,EAAGA,EAAIlB,EAAOI,OAAQc,IAAK,CACtC,IAAIC,EAAQnB,EAAOkB,GACfC,EAAMC,UAAUC,SAAS,yBAI7BhB,EAASiB,QAAQH,SAoCrB,SAA+BnB,GAE7B,IAAK,IAAIuB,EAAK,EAAGA,EAAKvB,EAAOI,OAAQmB,IAAM,CACzC,IAAIC,EAASxB,EAAOuB,GACpBR,EAAaS,IApDfC,CAAsBzB,GAiCxB,SAASe,EAAaI,GACpB,IAdkBO,EAcdC,EAAMR,EAAMS,QAAQD,IACxB,GAAKA,EAIL,OAnBkBD,EAmBAC,EAlBX,IAAIE,QAAQ,SAAUC,EAASC,GACpC,IAAIZ,EAAQ,IAAIa,MAChBb,EAAMQ,IAAMD,EACZP,EAAMc,OAASH,EACfX,EAAMe,QAAUH,KAcKI,KAAK,YAyD9B,SAAoBC,EAAKT,GAEvBS,EAAIhB,UAAUiB,IAAI,wBAClBD,EAAIT,IAAMA,EACVS,EAAIhB,UAAUiB,IAAI,eA5DhBC,CAAWnB,EAAOQ,KA+DtB,OAAOY","file":"dcf-lazyLoad.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n;(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n    module.exports = factory();\n  } else {\n    root.dcfLazyLoad = factory();\n  }\n})(undefined, function () {\n  // https://github.com/deanhume/lazy-observer-load/blob/master/lazy-load.js\n\n  // Get all of the images that are marked up to lazy load\n  var images = document.querySelectorAll('.dcf-lazy-img');\n  var config = {\n    // If the image gets within 50px in the Y axis, start the download.\n    //   rootMargin: '0px 0px 50px 0px',\n    rootMargin: '0px',\n    //   threshold: 0.01\n    threshold: 0.5\n  };\n\n  var imageCount = images.length;\n  var observer = void 0;\n\n  // If we don't have support for intersection observer, loads the images immediately\n  if (!('IntersectionObserver' in window)) {\n    loadImagesImmediately(images);\n  } else {\n    // It is supported, load the images\n    observer = new IntersectionObserver(onIntersection, config);\n\n    // foreach() is not supported in IE\n    for (var i = 0; i < images.length; i++) {\n      var image = images[i];\n      if (image.classList.contains('dcf-lazy-img-handled')) {\n        continue;\n      }\n\n      observer.observe(image);\n    }\n  }\n\n  /**\n   * Fetches the image for the given URL\n   * @param {string} url\n   */\n  function fetchImage(url) {\n    return new Promise(function (resolve, reject) {\n      var image = new Image();\n      image.src = url;\n      image.onload = resolve;\n      image.onerror = reject;\n    });\n  }\n\n  /**\n   * Preloads the image\n   * @param {object} image\n   */\n  function preloadImage(image) {\n    var src = image.dataset.src;\n    if (!src) {\n      return;\n    }\n\n    return fetchImage(src).then(function () {\n      applyImage(image, src);\n    });\n  }\n\n  /**\n   * Load all of the images immediately\n   * @param {NodeListOf<Element>} images\n   */\n  function loadImagesImmediately(images) {\n    // foreach() is not supported in IE\n    for (var _i = 0; _i < images.length; _i++) {\n      var _image = images[_i];\n      preloadImage(_image);\n    }\n  }\n\n  /**\n   * Disconnect the observer\n   */\n  function disconnect() {\n    if (!observer) {\n      return;\n    }\n\n    observer.disconnect();\n  }\n\n  /**\n   * On intersection\n   * @param {array} entries\n   */\n  function onIntersection(entries) {\n    // Disconnect if we've already loaded all of the images\n    if (imageCount === 0) {\n      observer.disconnect();\n    }\n\n    // Loop through the entries\n    for (var _i2 = 0; _i2 < entries.length; _i2++) {\n      var entry = entries[_i2];\n      // Are we in viewport?\n      if (entry.intersectionRatio > 0) {\n        imageCount--;\n\n        // Stop watching and load the image\n        observer.unobserve(entry.target);\n        preloadImage(entry.target);\n      }\n    }\n  }\n\n  /**\n   * Apply the image\n   * @param {object} img\n   * @param {string} src\n   */\n  function applyImage(img, src) {\n    // Prevent this from being lazy loaded a second time.\n    img.classList.add('dcf-lazy-img-handled');\n    img.src = src;\n    img.classList.add('dcf-fade-up');\n  }\n\n  return lazyLoad;\n});"]}