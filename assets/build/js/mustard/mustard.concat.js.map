{"version":3,"sources":["test-c.js","test-d.min.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"mustard.concat.js","sourcesContent":["//@license richard\nconsole.log('sayonara');\n// new very new comment line\n// a newer comment lin\n","// https://github.com/deanhume/lazy-observer-load/blob/master/lazy-load.js\n\n// Get all of the images that are marked up to lazy load\nconst images = document.querySelectorAll('.dcf-lazy-img');\nconst config = {\n\t// If the image gets within 50px in the Y axis, start the download.\n//   rootMargin: '0px 0px 50px 0px',\n\trootMargin: '0px',\n//   threshold: 0.01\n\tthreshold: 0.5\n};\n\nlet imageCount = images.length;\nlet observer;\n\n// If we don't have support for intersection observer, loads the images immediately\nif (!('IntersectionObserver' in window)) {\n\tloadImagesImmediately(images);\n} else {\n\t// It is supported, load the images\n\tobserver = new IntersectionObserver(onIntersection, config);\n\n\t// foreach() is not supported in IE\n\tfor (let i = 0; i < images.length; i++) {\n\t\tlet image = images[i];\n\t\tif (image.classList.contains('dcf-lazy-img-handled')) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tobserver.observe(image);\n\t}\n}\n\n/**\n * Fetches the image for the given URL\n * @param {string} url\n */\nfunction fetchImage(url) {\n\treturn new Promise((resolve, reject) => {\n\t\tconst image = new Image();\n\t\timage.src = url;\n\t\timage.onload = resolve;\n\t\timage.onerror = reject;\n\t});\n}\n\n/**\n * Preloads the image\n * @param {object} image\n */\nfunction preloadImage(image) {\n\tconst src = image.dataset.src;\n\tif (!src) {\n\t\treturn;\n\t}\n\n\treturn fetchImage(src).then(() => { applyImage(image, src); });\n}\n\n/**\n * Load all of the images immediately\n * @param {NodeListOf<Element>} images\n */\nfunction loadImagesImmediately(images) {\n\t// foreach() is not supported in IE\n\tfor (let i = 0; i < images.length; i++) {\n\t\tlet image = images[i];\n\t\tpreloadImage(image);\n\t}\n}\n\n/**\n * Disconnect the observer\n */\nfunction disconnect() {\n\tif (!observer) {\n\t\treturn;\n\t}\n\n\tobserver.disconnect();\n}\n\n/**\n * On intersection\n * @param {array} entries\n */\nfunction onIntersection(entries) {\n\t// Disconnect if we've already loaded all of the images\n\tif (imageCount === 0) {\n\t\tobserver.disconnect();\n\t}\n\n\t// Loop through the entries\n\tfor (let i = 0; i < entries.length; i++) {\n\t\tlet entry = entries[i];\n\t\t// Are we in viewport?\n\t\tif (entry.intersectionRatio > 0) {\n\t\t\timageCount--;\n\n\t\t\t// Stop watching and load the image\n\t\t\tobserver.unobserve(entry.target);\n\t\t\tpreloadImage(entry.target);\n\t\t}\n\t}\n}\n\n/**\n * Apply the image\n * @param {object} img\n * @param {string} src\n */\nfunction applyImage(img, src) {\n\t// Prevent this from being lazy loaded a second time.\n\timg.classList.add('dcf-lazy-img-handled');\n\timg.src = src;\n\timg.classList.add('dcf-fade-up');\n}\n"]}